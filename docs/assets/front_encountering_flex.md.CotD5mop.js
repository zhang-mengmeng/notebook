import{_ as e,c as i,a4 as t,o as a}from"./chunks/framework.DJY4F8Kc.js";const m=JSON.parse('{"title":"flex布局","description":"","frontmatter":{},"headers":[],"relativePath":"front/encountering/flex.md","filePath":"front/encountering/flex.md","lastUpdated":1739292668000}'),s={name:"front/encountering/flex.md"};function n(r,l,o,x,f,c){return a(),i("div",null,l[0]||(l[0]=[t('<h1 id="flex布局" tabindex="-1">flex布局 <a class="header-anchor" href="#flex布局" aria-label="Permalink to &quot;flex布局&quot;">​</a></h1><h2 id="邂逅flex布局" tabindex="-1">邂逅flex布局 <a class="header-anchor" href="#邂逅flex布局" aria-label="Permalink to &quot;邂逅flex布局&quot;">​</a></h2><h3 id="认识flexbox" tabindex="-1">认识flexbox <a class="header-anchor" href="#认识flexbox" aria-label="Permalink to &quot;认识flexbox&quot;">​</a></h3><ul><li><strong>flexbox翻译为弹性盒子</strong><ul><li>弹性盒子是一种用于按行或按列布局元素的一维布局方法</li><li>元素可以膨胀以填充额外的空间，收缩以适应更小的空间</li><li>通常我们使用flexbox来进行布局的方案称之为flex布局</li></ul></li><li><strong>flex布局是目前web开发中使用最多的布局方案</strong><ul><li>目前在移动端已经完全普及</li><li>在pc端也几乎已经完全普及和使用，只有非常少数的网站也依然在用浮动来布局</li></ul></li><li><strong>为什么需要flex布局</strong><ul><li>长久以来，css布局中唯一可靠且跨浏览器兼容的布局工具只有floats和positioning</li><li>但是这两种方法本身存在很大的局限性，并且他们用于布局实在是无奈之举</li></ul></li><li><strong>原先的布局存在的痛点</strong><ul><li>在父内容里面垂直居中一个块内容</li><li>使容器的所有子项等分可用宽度/高度，而不管有多少宽度/高度可用</li><li>使用多列布局中所有列采用相同的高度，即使它们包含的内容量不同</li></ul></li></ul><h2 id="flex布局概念" tabindex="-1">flex布局概念 <a class="header-anchor" href="#flex布局概念" aria-label="Permalink to &quot;flex布局概念&quot;">​</a></h2><h3 id="flex布局特性" tabindex="-1">flex布局特性 <a class="header-anchor" href="#flex布局特性" aria-label="Permalink to &quot;flex布局特性&quot;">​</a></h3><ul><li><strong>重要概念</strong><ul><li>开启了flex布局的元素叫flex container</li><li>flex container 里面的直接子元素叫做flex item</li></ul></li><li><strong>当flex container中的子元素变成了flex item时，具备以下特点</strong><ul><li>flex item的布局将受flex container属性的设置来进行控制和布局</li><li>flex item不再严格区分块级元素和行内元素</li><li>flex item默认情况下是包裹内容的，但是可以设置宽度和高度</li></ul></li><li><strong>设置 display 属性为 flex 或者 inline-flex 可以成为flex container</strong><ul><li>flex: flex container以block-level形式存在</li><li>inline-flex: flex container 以 inline-level形式存在</li></ul></li></ul><h3 id="flex模型" tabindex="-1">flex模型 <a class="header-anchor" href="#flex模型" aria-label="Permalink to &quot;flex模型&quot;">​</a></h3><ul><li><strong>主轴 or 交叉轴</strong><ul><li>main axis是主轴 main start 是主轴开始 main end 是主轴结束</li><li>cross axis是交叉轴 cross start是交叉轴开始 cross end 是交叉轴结束</li></ul></li></ul><h3 id="flex相关属性" tabindex="-1">flex相关属性 <a class="header-anchor" href="#flex相关属性" aria-label="Permalink to &quot;flex相关属性&quot;">​</a></h3><h4 id="应用在flex-container-上的css属性" tabindex="-1">应用在flex container 上的css属性 <a class="header-anchor" href="#应用在flex-container-上的css属性" aria-label="Permalink to &quot;应用在flex container 上的css属性&quot;">​</a></h4><ul><li><strong>flex-direction</strong><ul><li>flex items 默认都是沿着 main axis 从 main start 开始往 main end 方向排布</li><li>flex-direction决定了main axis的方向，有4个取值 row(默认值) row-reverse column column-reverse</li></ul></li><li><strong>flex-wrap</strong><ul><li>nowrap(默认)：单行</li><li>wrap：多行</li><li>wrap-reverse：多行(对比 wrap cross start与cross end 相反)</li></ul></li><li><strong>flex-flow</strong><ul><li>flex-flow属性是flex-direction 和 flex-wrap 的简写 顺序任何，并且都可以省略</li></ul></li><li><strong>justify-content</strong><ul><li>决定了 flex items 在 main axis 上的对齐方式</li><li>flex-start(默认值)：与 main start 对其</li><li>flex-end：与 main end 对齐</li><li>center：居中对齐</li><li>space-between：flex items 之间的距离相等 与 main start、main end两端对齐</li><li>space-around：flex items 之间的距离相等 与 main start、main end 之间的距离是flex items 之间距离的一半</li><li>space-evenly：flex items 之间的距离相等 与 main start、main end 之间的距离 等于 flex items 之间的距离</li></ul></li><li><strong>align-item</strong><ul><li>决定了 flex items 在 cross axis 上的对齐方式</li><li>normal：在弹性布局中，效果和stretch一样</li><li>stretch：当 flex items 在 cross axis 方向的 size 为 auto 时，会自动拉伸至填充 flex container</li><li>flex-start：与 cross start 对齐</li><li>flex-end：与 cross end 对齐</li><li>center：居中对齐</li><li>baseline：与基线对齐</li></ul></li><li><strong>align-content</strong><ul><li>决定了对行 flex items 在 cross axis 上的对齐方式，</li><li>stretch(默认值)：与 align-items 的 stretch 类似</li><li>flex-start：与cross start 对齐</li><li>flex-end：cross end 对齐</li><li>center：居中对齐</li><li>space-between：flex items 之间的距离相等 与 cross start、cross end两端对齐</li><li>space-around：flex items 之间的距离相等 与 cross start、cross end 之间的距离是 flex items 之间距离的一半</li><li>space-evenly：flex items 之间的距离相等 与 cross start、cross end 之间的距离等于 flex items 之间的距离</li></ul></li></ul><h4 id="应用在flex-items-上的css属性" tabindex="-1">应用在flex items 上的css属性 <a class="header-anchor" href="#应用在flex-items-上的css属性" aria-label="Permalink to &quot;应用在flex items 上的css属性&quot;">​</a></h4><ul><li><strong>order</strong><ul><li>决定了 flex items 的排布顺序 可以设置任意整数 值越小就越排在前面</li></ul></li><li><strong>align-self</strong><ul><li>auto(默认值)：遵从 flex container 的 align-items 设置</li><li>stretch、flex-start、flex-end、center、baseline、效果跟 align-items 一致</li></ul></li><li><strong>flex-grow</strong><ul><li>决定了 flex items 如何扩展</li><li>可以设置任意非数字</li></ul></li></ul>',14)]))}const d=e(s,[["render",n]]);export{m as __pageData,d as default};
