import{_ as l,c as a,a4 as r,o as i}from"./chunks/framework.DJY4F8Kc.js";const S=JSON.parse('{"title":"浏览器的渲染原理","description":"","frontmatter":{},"headers":[],"relativePath":"front/javascript/rendering.md","filePath":"front/javascript/rendering.md","lastUpdated":1743430814000}'),t={name:"front/javascript/rendering.md"};function d(o,e,n,c,u,s){return i(),a("div",null,e[0]||(e[0]=[r('<h1 id="浏览器的渲染原理" tabindex="-1">浏览器的渲染原理 <a class="header-anchor" href="#浏览器的渲染原理" aria-label="Permalink to &quot;浏览器的渲染原理&quot;">​</a></h1><h2 id="url加载过程" tabindex="-1">URL加载过程 <a class="header-anchor" href="#url加载过程" aria-label="Permalink to &quot;URL加载过程&quot;">​</a></h2><ul><li>在URL中输入域名，通过DNS解析，拿到服务器地址，服务器返回数据到浏览器</li></ul><h2 id="浏览器页面渲染的流程" tabindex="-1">浏览器页面渲染的流程 <a class="header-anchor" href="#浏览器页面渲染的流程" aria-label="Permalink to &quot;浏览器页面渲染的流程&quot;">​</a></h2><h3 id="html解析过程" tabindex="-1">HTML解析过程 <a class="header-anchor" href="#html解析过程" aria-label="Permalink to &quot;HTML解析过程&quot;">​</a></h3><ul><li>默认情况下服务器会给浏览器返回index.html文件，所以解析HTML是所有步骤的开始</li><li>解析HTML，会构建DOM Tree</li></ul><h3 id="生成css规则" tabindex="-1">生成CSS规则 <a class="header-anchor" href="#生成css规则" aria-label="Permalink to &quot;生成CSS规则&quot;">​</a></h3><ul><li>在解析的过程中，如果遇到CSS的link元素，那么会由浏览器负责下载对应的CSS文件 <ul><li>下载CSS文件是不会影响DOM的解析的</li></ul></li><li>浏览器下载完CSS文件后，就会对CSS文件进行解析，<code>解析出对应的规则树</code><ul><li>我们可以称之为<code>CSSOM</code>(CSS Object Model, CSS对象模型)</li></ul></li></ul><h3 id="构建render-tree" tabindex="-1">构建Render Tree <a class="header-anchor" href="#构建render-tree" aria-label="Permalink to &quot;构建Render Tree&quot;">​</a></h3><ul><li>当有了DOM Tree和 CSSOM Tree后，就可以两个结合构建<code>Render Tree</code>了</li><li><code>link元素不会阻塞DOM Tree的构建过程</code>，但是<code>会阻塞Render Tree的构建过程</code><ul><li>这是因为Render Tree在构建时，需要对应的CSSOM Tree</li></ul></li><li><code>Render Tree和DOM Tree并不是一一对应的关系</code>,比如对于display为none的元素，压根不会出现在render tree中。</li></ul><h2 id="script和页面解析的关系" tabindex="-1">script和页面解析的关系 <a class="header-anchor" href="#script和页面解析的关系" aria-label="Permalink to &quot;script和页面解析的关系&quot;">​</a></h2><h3 id="了解" tabindex="-1">了解 <a class="header-anchor" href="#了解" aria-label="Permalink to &quot;了解&quot;">​</a></h3><ul><li>JavaScript在哪里 <ul><li>浏览器在解析HTML的过程中，遇到了script元素是不能继续构建DOM树的</li><li>它会停止继续构建，首先下载JavaScript代码，并且执行JavaScript脚本</li><li>只有等到JavaScript脚本结束后，才会继续解析HTML,构建DOM树</li></ul></li><li>为什么这样做 <ul><li>这是因为JavaScript的作用之一就是操作DOM，并且可以修改DOM</li><li>如果我们等到DOM树构建完成并且渲染再执行JavaScript，会造成严重的回流和重绘，影响页面的性能</li><li>所以会在遇到script元素时，优先下载和执行JavaScript代码，再继续构建DOM树</li></ul></li><li>但是在现代页面开发中 <ul><li>脚本往往比HTML页面更&quot;重&quot;，处理时间需要更长</li><li>所以会造成页面的解析阻塞，在脚本下载执行完成之前，用户在界面上什么都看不到</li></ul></li><li>为了解决这个问题，script元素给我提供了两个属性(attribute): defer和async</li></ul><h3 id="defer属性" tabindex="-1">defer属性 <a class="header-anchor" href="#defer属性" aria-label="Permalink to &quot;defer属性&quot;">​</a></h3><ul><li>defer属性告诉浏览器不要等待脚本下载，而是继续解析HTML,构建DOM Tree <ul><li>脚本会由浏览器进行下载，但是不会阻塞DOM Tree的构建过程</li><li>如果脚本提前下载好了，它会等待DOM Tree构建完成，在DOMConentLoaded事件之前先执行defer中的代码</li></ul></li><li>DOMContentLoaded总会等待defer中的代码先执行完成</li><li>多个带defer的脚本是可以保持正确的顺序执行的</li><li>从某种角度来说，defer可以提高页面的性能，并且推荐放到head元素中</li><li>defer仅适用于外部脚本，对于script默认内容会被忽略</li></ul>',15)]))}const f=l(t,[["render",d]]);export{S as __pageData,f as default};
