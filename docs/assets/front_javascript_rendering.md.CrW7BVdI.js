import{_ as e,c as i,a4 as a,o as r}from"./chunks/framework.DJY4F8Kc.js";const p=JSON.parse('{"title":"浏览器的渲染原理","description":"","frontmatter":{},"headers":[],"relativePath":"front/javascript/rendering.md","filePath":"front/javascript/rendering.md","lastUpdated":1747234668000}'),t={name:"front/javascript/rendering.md"};function o(d,l,n,c,u,h){return r(),i("div",null,l[0]||(l[0]=[a('<h1 id="浏览器的渲染原理" tabindex="-1">浏览器的渲染原理 <a class="header-anchor" href="#浏览器的渲染原理" aria-label="Permalink to &quot;浏览器的渲染原理&quot;">​</a></h1><h2 id="url加载过程" tabindex="-1">URL加载过程 <a class="header-anchor" href="#url加载过程" aria-label="Permalink to &quot;URL加载过程&quot;">​</a></h2><ul><li>在URL中输入域名，通过DNS解析，拿到服务器地址，服务器返回数据到浏览器</li></ul><h2 id="浏览器页面渲染的流程" tabindex="-1">浏览器页面渲染的流程 <a class="header-anchor" href="#浏览器页面渲染的流程" aria-label="Permalink to &quot;浏览器页面渲染的流程&quot;">​</a></h2><h3 id="html解析过程" tabindex="-1">HTML解析过程 <a class="header-anchor" href="#html解析过程" aria-label="Permalink to &quot;HTML解析过程&quot;">​</a></h3><ul><li>默认情况下服务器会给浏览器返回index.html文件，所以解析HTML是所有步骤的开始</li><li>解析HTML，会构建DOM Tree</li></ul><h3 id="生成css规则" tabindex="-1">生成CSS规则 <a class="header-anchor" href="#生成css规则" aria-label="Permalink to &quot;生成CSS规则&quot;">​</a></h3><ul><li>在解析的过程中，如果遇到CSS的link元素，那么会由浏览器负责下载对应的CSS文件 <ul><li>下载CSS文件是不会影响DOM的解析的</li></ul></li><li>浏览器下载完CSS文件后，就会对CSS文件进行解析，<code>解析出对应的规则树</code><ul><li>我们可以称之为<code>CSSOM</code>(CSS Object Model, CSS对象模型)</li></ul></li></ul><h3 id="构建render-tree" tabindex="-1">构建Render Tree <a class="header-anchor" href="#构建render-tree" aria-label="Permalink to &quot;构建Render Tree&quot;">​</a></h3><ul><li>当有了DOM Tree和 CSSOM Tree后，就可以两个结合构建<code>Render Tree</code>了</li><li><code>link元素不会阻塞DOM Tree的构建过程</code>，但是<code>会阻塞Render Tree的构建过程</code><ul><li>这是因为Render Tree在构建时，需要对应的CSSOM Tree</li></ul></li><li><code>Render Tree和DOM Tree并不是一一对应的关系</code>,比如对于display为none的元素，压根不会出现在render tree中。</li></ul><h3 id="布局-layout" tabindex="-1">布局（layout） <a class="header-anchor" href="#布局-layout" aria-label="Permalink to &quot;布局（layout）&quot;">​</a></h3><ul><li>在渲染树上运行布局，计算每个节点的几何体</li><li>渲染树会表示显示哪些节点以及其他样式，但是<code>不表示每个节点的尺寸、位置</code>等信息</li><li>布局就确定渲染树中<code>所有节点的宽度、高度和位置信息</code></li></ul><h3 id="绘制-paint" tabindex="-1">绘制（Paint） <a class="header-anchor" href="#绘制-paint" aria-label="Permalink to &quot;绘制（Paint）&quot;">​</a></h3><ul><li>在绘制阶段，浏览器将布局阶段计算的<code>每个frame转为屏幕上实际的像素点</code></li><li>包括<code>将元素的可见部分进行绘制</code>，比如<code>文本 颜色 边框 阴影 替换元素(img)</code></li></ul><h3 id="特殊解析-composite合成" tabindex="-1">特殊解析 - composite合成 <a class="header-anchor" href="#特殊解析-composite合成" aria-label="Permalink to &quot;特殊解析 - composite合成&quot;">​</a></h3><ul><li>绘制的过程，可以将布局后的元素绘制到多个合成图层中 <ul><li>这是浏览器的一种优化手段</li></ul></li><li>默认情况下，标准流中的内容都是被绘制在同一个合成图层中的</li><li>而一些特殊的属性，会创建一个新的合成层，并且新的图层可以利用GPU来加速绘制 <ul><li>因为每个合成层都是单独渲染的</li></ul></li><li>生成新的合成层的一些属性 <ul><li>3D transforms</li><li>video canvas iframe</li><li>opacity动画转换时</li><li>position: fixed</li><li>will-change：一个实验性的属性，提前告诉浏览器元素可能发生哪些变化</li><li>animation 或 transition 设置了 opacity transform</li></ul></li><li>分层确实可以提高性能，但是它以内存管理为代价，因此不应作为web性能优化策略的一部分过度使用</li></ul><h2 id="回流-reflow" tabindex="-1">回流（reflow) <a class="header-anchor" href="#回流-reflow" aria-label="Permalink to &quot;回流（reflow)&quot;">​</a></h2><ul><li>第一次确定节点的大小和位置，称之为布局（layout）</li><li>之后对节点的大小、位置修改重新计算称之为回流。</li></ul><h3 id="什么情况下引起回流" tabindex="-1">什么情况下引起回流 <a class="header-anchor" href="#什么情况下引起回流" aria-label="Permalink to &quot;什么情况下引起回流&quot;">​</a></h3><ul><li>比如DOM结构发生改变（添加新的节点或者移除节点）</li><li>比如改变了布局（修改了 width height padding font-size）</li><li>比如窗口resize（修改了窗口的尺寸）</li><li>比如调用getComputedStyle方法获取尺寸，位置信息</li></ul><h3 id="如何避免回流" tabindex="-1">如何避免回流 <a class="header-anchor" href="#如何避免回流" aria-label="Permalink to &quot;如何避免回流&quot;">​</a></h3><ul><li><p>修改样式时尽量一次性修改</p><ul><li>比如通过css Text修改，比如通过添加class修改</li></ul></li><li><p>尽量避免频繁的操作DOM</p><ul><li>我们可以在一个DocumentFragment或者父元素中将要操作的DOM操作完成，再一次性的操作</li></ul></li><li><p>尽量避免通过getComputedStyle获取尺寸，位置等信息</p></li><li><p>对某些元素使用position的absolute或者fixed</p><ul><li>并不是不会引起回流，而是开销相对较小，不会对其他元素造成影响。</li></ul></li></ul><h2 id="重绘" tabindex="-1">重绘 <a class="header-anchor" href="#重绘" aria-label="Permalink to &quot;重绘&quot;">​</a></h2><ul><li>第一次渲染内容称之为绘制</li><li>之后重新渲染称之为重绘</li></ul><h3 id="什么情况下会引起重绘" tabindex="-1">什么情况下会引起重绘 <a class="header-anchor" href="#什么情况下会引起重绘" aria-label="Permalink to &quot;什么情况下会引起重绘&quot;">​</a></h3><ul><li>比如修改背景色 文字颜色 边框颜色 样式等</li></ul><h2 id="script和页面解析的关系" tabindex="-1">script和页面解析的关系 <a class="header-anchor" href="#script和页面解析的关系" aria-label="Permalink to &quot;script和页面解析的关系&quot;">​</a></h2><h3 id="了解" tabindex="-1">了解 <a class="header-anchor" href="#了解" aria-label="Permalink to &quot;了解&quot;">​</a></h3><ul><li>JavaScript在哪里 <ul><li>浏览器在解析HTML的过程中，遇到了script元素是不能继续构建DOM树的</li><li>它会停止继续构建，首先下载JavaScript代码，并且执行JavaScript脚本</li><li>只有等到JavaScript脚本结束后，才会继续解析HTML,构建DOM树</li></ul></li><li>为什么这样做 <ul><li>这是因为JavaScript的作用之一就是操作DOM，并且可以修改DOM</li><li>如果我们等到DOM树构建完成并且渲染再执行JavaScript，会造成严重的回流和重绘，影响页面的性能</li><li>所以会在遇到script元素时，优先下载和执行JavaScript代码，再继续构建DOM树</li></ul></li><li>但是在现代页面开发中 <ul><li>脚本往往比HTML页面更&quot;重&quot;，处理时间需要更长</li><li>所以会造成页面的解析阻塞，在脚本下载执行完成之前，用户在界面上什么都看不到</li></ul></li><li>为了解决这个问题，script元素给我提供了两个属性(attribute): defer和async</li></ul><h3 id="defer属性" tabindex="-1">defer属性 <a class="header-anchor" href="#defer属性" aria-label="Permalink to &quot;defer属性&quot;">​</a></h3><ul><li>defer属性告诉浏览器不要等待脚本下载，而是继续解析HTML,构建DOM Tree <ul><li>脚本会由浏览器进行下载，但是不会阻塞DOM Tree的构建过程</li><li>如果脚本提前下载好了，它会等待DOM Tree构建完成，在DOMConentLoaded事件之前先执行defer中的代码</li></ul></li><li>DOMContentLoaded总会等待defer中的代码先执行完成</li><li>多个带defer的脚本是可以保持正确的顺序执行的</li><li>从某种角度来说，defer可以提高页面的性能，并且推荐放到head元素中</li><li>defer仅适用于外部脚本，对于script默认内容会被忽略</li></ul><h3 id="async属性" tabindex="-1">async属性 <a class="header-anchor" href="#async属性" aria-label="Permalink to &quot;async属性&quot;">​</a></h3><ul><li>async 特性与defer有些类似，它能够让脚本不阻塞页面</li><li>async是让一个脚本完全独立的 <ul><li>浏览器不会因为async脚本而阻塞DOM树的构建</li><li>async脚本不能保证顺序，它是独立下载，独立运行，不会等待其他脚本</li><li>async不会能保证在DOMContentLoaded之前或者之后执行</li></ul></li><li>defer通常用于需要在文档解析后操作AOM的JavaScript代码，并且对多个script文件有顺序要求的</li><li>async通常用于独立的脚本，对其他脚本，甚至DOM没有依赖的</li></ul>',33)]))}const f=e(t,[["render",o]]);export{p as __pageData,f as default};
